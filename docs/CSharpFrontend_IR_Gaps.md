# C# Frontend IR Gaps

The ObjectIR C# frontend currently emits placeholder IR that diverges significantly from the production-quality output generated by the Fortran compiler. This note captures the differences and the resulting requirements before we implement repairs.

## Reference Outputs

### Fortran frontend (`src/OIFortran/test.json`)
```json
{
  "Name": "test",
  "Types": [
    {
      "Kind": "Class",
      "Name": "test",
      "Methods": [
        {
          "Name": "Main",
          "ReturnType": "void",
          "LocalVariables": [
            { "Name": "x", "Type": "int32" },
            { "Name": "result", "Type": "int32" }
          ],
          "Instructions": [
            { "opCode": "ldloc", "operand": { "localName": "x" } },
            { "opCode": "ldloc", "operand": { "localName": "y" } },
            { "opCode": "add" },
            { "opCode": "stloc", "operand": { "localName": "result" } },
            { "opCode": "call", "operand": { "method": { "declaringType": "System.Console", "name": "WriteLine" } } },
            { "opCode": "ret" }
          ]
        }
      ]
    }
  ]
}
```

### C# frontend (`src/ObjectIR.CSharpFrontend/FrontendWithBodies.ir.json`)
```json
{
  "Name": "FrontendWithBodies",
  "Types": [
    {
      "Name": "CommandLineParser",
      "Kind": "Class",
      "Methods": [
        {
          "Name": "Parse",
          "ReturnType": "<global namespace>.CompilerOptions",
          "InstructionCount": 36,
          "Instructions": [
            { "Type": "NewObject", "ObjectType": "object" },
            { "Type": "LoadLocal", "LocalName": "i" },
            { "Type": "Arithmetic", "Operation": "Add" },
            { "Type": "While", "BodyInstructions": 17 },
            { "Type": "If", "ThenBlockInstructions": 2 },
            { "Type": "Return" }
          ]
        }
      ]
    }
  ]
}
```

## Observed Differences

| Aspect | Fortran output | C# output | Impact |
| --- | --- | --- | --- |
| Type metadata | Fully populated (Access = "Public", Namespace = logical module path). | Access emitted as numeric enum; namespaces collapse to `"<global namespace>"`. | Cosmetic but signals inconsistent serialization.
| Method metadata | Parameters, locals, flags, and instruction counts align with actual source. | Locals collection is empty and parameters repeat default names even when rewritten. | IR consumers (optimizers, backends, serializer) cannot reason about stack slots.
| Instruction representation | Low-level opcodes (`ldloc`, `ldc`, `call`, `stloc`, `ret`) that mirror the stack machine used everywhere else. | High-level placeholders (`NewObject` with `object`, `Arithmetic:Add`, structured `While`/`If` nodes with empty conditions). | Downstream tools cannot rehydrate actual code, and instructions are semantically incorrect.
| Control-flow encoding | Each branch/loop is driven by explicit stack comparisons; boolean expressions exist as comparison instructions. | Conditions emit generic `Arithmetic:Add` nodes, so even `i < count` becomes an addition with no comparison metadata. | `While`/`If` instructions have unusable conditions, preventing round-tripping or execution.
| Diagnostics | Fortran pipeline materializes real runtime calls (e.g., `System.Console.WriteLine`). | C# emitter never resolves method symbols for call sites, so no `CallInstruction` appears in output. | Anything beyond trivial struct layout is missing from the IR.

## Requirements for the C# Frontend

1. **Type & method metadata** – ensure `MethodDefinition.Locals`, access modifiers, and namespaces are populated with semantic information (no anonymous `object` placeholders).
2. **Expression lowering** – translate Roslyn binary expressions into `ArithmeticInstruction` or `ComparisonInstruction` as appropriate instead of always defaulting to addition.
3. **Condition handling** – emit boolean-producing instructions (and/or populate `Condition.Binary`) so `IfInstruction`/`WhileInstruction` carry meaningful predicates.
4. **Call resolution** – use Roslyn symbol info to build `MethodReference`/`FieldReference` objects that match actual signatures (the plumbing already exists in `CompileMethodCall`, but it currently never surfaces because prerequisite stack state is wrong).
5. **Parity validation** – rerun the frontend on the `CommandLineParser` inputs and compare the resulting JSON with a Fortran sample to ensure we now expose locals, stack ops, comparisons, and calls the same way.

These gaps drive the implementation work tracked in this session (fixing `CSharpBodyCompiler` and related emitters so the JSON resembles the proven Fortran output).
